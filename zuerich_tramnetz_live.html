<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Z√ºrich Tramnetz Live - Mit Haltestellen</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; }
    
    #reload {
      position: absolute; top: 10px; right: 10px;
      background: white; border-radius: 8px; padding: 8px 14px;
      box-shadow: 0 3px 8px rgba(0,0,0,0.2); font-family: sans-serif;
      cursor: pointer; font-weight: 600; z-index: 1000;
      transition: background 0.2s;
    }
    #reload:hover { background: #f0f0f0; }
    #reload:disabled { opacity: 0.5; cursor: not-allowed; }
    
    .control-panel {
      position: absolute; top: 10px;
      background: white; border-radius: 8px; padding: 12px;
      box-shadow: 0 3px 8px rgba(0,0,0,0.2); 
      font-family: sans-serif; z-index: 1000;
      max-height: 80vh; overflow-y: auto;
    }
    
    #lineControl { left: 10px; min-width: 200px; }
    #accessibilityControl { left: 230px; min-width: 200px; }
    #vehicleControl { left: 450px; min-width: 250px; }
    
    .control-panel h3 {
      margin: 0 0 10px 0; font-size: 16px; 
      border-bottom: 2px solid #ddd; padding-bottom: 8px;
    }
    
    .checkbox-option {
      display: flex; align-items: center; 
      margin: 6px 0; cursor: pointer;
      padding: 4px; border-radius: 4px;
      transition: background 0.2s;
    }
    
    .checkbox-option:hover { background: #f5f5f5; }
    
    .checkbox-option input[type="checkbox"] {
      margin-right: 8px; cursor: pointer;
      width: 18px; height: 18px;
    }
    
    .stats-section {
      margin-top: 10px; padding-top: 8px;
      border-top: 1px solid #ddd; font-size: 13px; color: #666;
    }
    
    .line-label {
      display: flex; align-items: center;
      gap: 8px; font-size: 14px;
    }
    
    .line-color-box {
      width: 24px; height: 24px; 
      border-radius: 3px; border: 2px solid #333;
      display: inline-block; flex-shrink: 0;
    }
    
    .control-buttons {
      margin-top: 12px; padding-top: 8px;
      border-top: 1px solid #ddd; display: flex; gap: 6px;
    }
    
    .control-btn {
      flex: 1; padding: 6px; 
      background: #f0f0f0; border: 1px solid #ccc;
      border-radius: 4px; cursor: pointer;
      font-size: 12px; font-weight: 500;
      transition: background 0.2s;
    }
    
    .control-btn:hover { background: #e0e0e0; }
    
    .vehicle-marker {
      background: white; 
      border: 3px solid #333;
      border-radius: 50%; 
      padding: 8px;
      font-weight: bold; 
      font-size: 13px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.6);
      white-space: nowrap;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    }
    
    .vehicle-marker.accelerating {
      transform: scale(1.1);
      box-shadow: 0 0 15px rgba(245, 158, 11, 0.7);
    }
    
    .vehicle-marker.braking {
      transform: scale(0.95);
      box-shadow: 0 0 15px rgba(239, 68, 68, 0.7);
    }
    
    .vehicle-marker.stopped {
      opacity: 0.9;
    }
    
    .leaflet-popup-content { 
      font-family: sans-serif; 
      font-size: 14px; min-width: 250px;
    }
    
    .popup-header {
      font-size: 16px; font-weight: bold;
      margin-bottom: 8px; padding-bottom: 6px;
      border-bottom: 2px solid #ddd;
    }
    
    .popup-section {
      margin: 8px 0; line-height: 1.6;
    }
    
    .delay-indicator {
      display: inline-block; padding: 2px 6px;
      border-radius: 3px; font-size: 11px;
      font-weight: bold; margin-left: 4px;
    }
    
    .delay-ontime { background: #22c55e; color: white; }
    .delay-minor { background: #f59e0b; color: white; }
    .delay-major { background: #ef4444; color: white; }
    
    .legend-item {
      display: flex; align-items: center;
      margin: 4px 0; gap: 8px; font-size: 13px;
    }
    
    .legend-dot {
      width: 12px; height: 12px;
      border-radius: 50%; border: 2px solid #333;
      flex-shrink: 0;
    }
    
    .loading-indicator {
      padding: 8px; background: #fff3cd; border-radius: 4px;
      margin-top: 8px; font-size: 12px; color: #856404;
    }
    
    .error-indicator {
      padding: 8px; background: #f8d7da; border-radius: 4px;
      margin-top: 8px; font-size: 12px; color: #721c24;
    }
  </style>
</head>
<body>
<div id="map"></div>

<button id="reload" aria-label="Daten neu laden">üîÑ Aktualisieren</button>

<div id="lineControl" class="control-panel">
  <h3>üöä Tramlinien</h3>
  <div id="lineCheckboxes"></div>
  <div class="control-buttons">
    <button class="control-btn" onclick="app.toggleAllLines(true)">Alle</button>
    <button class="control-btn" onclick="app.toggleAllLines(false)">Keine</button>
  </div>
</div>

<div id="accessibilityControl" class="control-panel">
  <h3>‚ôø Haltestellen</h3>
  <div class="checkbox-option">
    <input type="checkbox" id="showStops" checked onchange="app.filterStops()">
    <label for="showStops">Haltestellen anzeigen</label>
  </div>
  <div class="stats-section">
    <div class="legend-item">
      <span class="legend-dot" style="background: #22c55e;"></span>
      <span>Barrierefrei</span>
    </div>
    <div class="legend-item">
      <span class="legend-dot" style="background: #ef4444;"></span>
      <span>Nicht barrierefrei</span>
    </div>
    <div class="legend-item">
      <span class="legend-dot" style="background: #94a3b8;"></span>
      <span>Unbekannt</span>
    </div>
  </div>
  <div id="stopsStatus"></div>
</div>

<div id="vehicleControl" class="control-panel">
  <h3>üöã Live-Fahrzeuge</h3>
  <div class="checkbox-option">
    <input type="checkbox" id="showVehicles" checked onchange="app.toggleVehicles()">
    <label for="showVehicles" style="font-weight: 600;">Fahrzeuge anzeigen</label>
  </div>
  <div class="checkbox-option">
    <input type="checkbox" id="animateOnTracks" checked>
    <label for="animateOnTracks">Auf Gleisen bewegen</label>
  </div>
  <div class="stats-section" id="vehicleStats">
    Initialisiere...
  </div>
</div>

<script>
// ==================== KONFIGURATION ====================
const CONFIG = {
  MAP_CENTER: [47.3769, 8.5417],
  MAP_ZOOM: 13,
  VEHICLE_UPDATE_INTERVAL: 20000,
  ANIMATION_FPS: 60,
  STOP_DURATION: 30, // 30 Sekunden Haltezeit an Stationen
  ACCELERATION_TIME: 12, // 12 Sekunden zum Beschleunigen
  BRAKING_TIME: 15, // 15 Sekunden zum Bremsen
  MAX_SPEED: 40,
  LINE_COLORS: {
    '2': '#ED1C24', '3': '#00A651', '4': '#0066B3', '5': '#8B5B29',
    '6': '#F7941D', '7': '#000000', '8': '#8B5B29', '9': '#0066B3',
    '10': '#E6007E', '11': '#00A651', '12': '#8B5B29', '13': '#FFDD00',
    '14': '#0066B3', '15': '#ED1C24', '17': '#8B5B29'
  },
  MAJOR_STOPS: [
    'Z√ºrich HB', 'Z√ºrich, Bellevue', 'Z√ºrich, Paradeplatz',
    'Z√ºrich, Central', 'Z√ºrich, Bahnhofquai/HB', 'Z√ºrich, B√ºrkliplatz',
    'Z√ºrich Oerlikon', 'Z√ºrich, Helvetiaplatz', 'Z√ºrich Altstetten',
    'Z√ºrich, Limmatplatz', 'Z√ºrich, Albisriederplatz'
  ]
};

// ==================== HAUPTAPPLIKATION ====================
const app = {
  map: null,
  vehicleLayer: null,
  tramLayer: null,
  lineLayers: {},
  vehicleMarkers: {},
  lineGeometries: {},
  vehicleAnimationState: {},
  stopMarkers: [],
  stopCoordinates: {},
  animationFrameId: null,
  isLoading: false,

  // Initialisierung
  async init() {
    console.log('üöÄ Initialisiere Tramnetz-Visualisierung');
    
    this.map = L.map('map').setView(CONFIG.MAP_CENTER, CONFIG.MAP_ZOOM);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '¬© OpenStreetMap'
    }).addTo(this.map);

    this.vehicleLayer = L.layerGroup().addTo(this.map);
    this.tramLayer = L.layerGroup().addTo(this.map);

    // Event-Listener
    document.getElementById('reload').addEventListener('click', () => this.reload());

    // Initiales Laden
    await this.loadAll();
    
    // Animation starten
    this.startAnimation();
    
    // Periodische Updates
    setInterval(() => this.loadVehicles(), CONFIG.VEHICLE_UPDATE_INTERVAL);
    
    console.log('‚úÖ Initialisierung abgeschlossen');
  },

  // Alle Daten laden
  async loadAll() {
    if (this.isLoading) return;
    this.isLoading = true;
    
    const reloadBtn = document.getElementById('reload');
    reloadBtn.disabled = true;
    reloadBtn.textContent = '‚è≥ L√§dt...';

    try {
      await Promise.all([
        this.loadLines(),
        this.loadStops()
      ]);
      
      // Warte kurz, damit Linien verf√ºgbar sind
      await new Promise(resolve => setTimeout(resolve, 1000));
      await this.loadVehicles();
      
    } catch (error) {
      console.error('Fehler beim Laden:', error);
      this.showError('vehicleStats', 'Fehler beim Laden der Daten');
    } finally {
      this.isLoading = false;
      reloadBtn.disabled = false;
      reloadBtn.textContent = 'üîÑ Aktualisieren';
    }
  },

  // Neu laden
  async reload() {
    console.log('üîÑ Aktualisiere Daten...');
    await this.loadAll();
  },

  // ==================== LINIEN ====================
  async loadLines() {
    this.showLoading('lineCheckboxes', 'Lade Linien...');
    
    try {
      // Alte Linien entfernen
      Object.values(this.lineLayers).forEach(layer => {
        if (this.map.hasLayer(layer)) {
          this.map.removeLayer(layer);
        }
      });
      this.lineLayers = {};
      this.lineGeometries = {};

      const overpassQuery = `
        [out:json][timeout:30];
        (relation["route"="tram"]["ref"](47.32,8.45,47.43,8.62););
        out geom;
      `;

      const response = await fetch('https://overpass-api.de/api/interpreter', {
        method: 'POST',
        body: overpassQuery,
        headers: { 'Content-Type': 'text/plain' }
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      const data = await response.json();
      
      if (!data.elements || data.elements.length === 0) {
        console.warn('Keine OSM-Linien gefunden, verwende GTFS Fallback');
        await this.loadGTFSShapes();
        return;
      }

      // Linien verarbeiten
      data.elements.forEach(relation => {
        if (relation.type === 'relation' && relation.tags) {
          const ref = relation.tags.ref || '';
          const lineNumber = ref.split(';')[0].trim();
          const color = CONFIG.LINE_COLORS[lineNumber] || '#0066B3';

          if (!this.lineLayers[lineNumber]) {
            this.lineLayers[lineNumber] = L.layerGroup();
            this.lineLayers[lineNumber].addTo(this.map);
            this.lineGeometries[lineNumber] = [];
          }

          if (relation.members) {
            relation.members.forEach(member => {
              if (member.type === 'way' && member.geometry && 
                  (!member.role || ['', 'forward', 'backward'].includes(member.role))) {
                
                const coords = member.geometry
                  .filter(p => p.lat && p.lon)
                  .map(p => [p.lat, p.lon]);

                if (coords.length >= 2) {
                  this.lineGeometries[lineNumber].push(...coords);
                  
                  L.polyline(coords, {
                    color: color, weight: 4, opacity: 0.7,
                    lineJoin: 'round', lineCap: 'round'
                  }).addTo(this.lineLayers[lineNumber])
                    .bindPopup(`<b>Linie ${lineNumber}</b>`);
                }
              }
            });
          }
        }
      });

      console.log(`‚úÖ ${Object.keys(this.lineLayers).length} Linien geladen`);
      this.updateLineControl();
      
    } catch (error) {
      console.error('Fehler beim Laden der Linien:', error);
      this.showError('lineCheckboxes', 'Fehler beim Laden der Linien');
      await this.loadGTFSShapes();
    }
  },

  async loadGTFSShapes() {
    try {
      const response = await fetch('https://gtfs.geops.ch/dl/tram/shapes.txt');
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      
      const csvText = await response.text();
      const parsed = Papa.parse(csvText, { header: true, skipEmptyLines: true });

      const shapeGroups = {};
      parsed.data.forEach(row => {
        if (row.shape_id && row.shape_pt_lat && row.shape_pt_lon) {
          if (!shapeGroups[row.shape_id]) {
            shapeGroups[row.shape_id] = [];
          }
          shapeGroups[row.shape_id].push({
            lat: parseFloat(row.shape_pt_lat),
            lon: parseFloat(row.shape_pt_lon),
            seq: parseInt(row.shape_pt_sequence) || 0
          });
        }
      });

      if (!this.lineLayers['fallback']) {
        this.lineLayers['fallback'] = L.layerGroup().addTo(this.map);
        this.lineGeometries['fallback'] = [];
      }

      let count = 0;
      Object.keys(shapeGroups).forEach(shapeId => {
        const points = shapeGroups[shapeId];
        points.sort((a, b) => a.seq - b.seq);
        
        const coords = points.map(p => [p.lat, p.lon]);
        
        if (coords.length >= 2) {
          this.lineGeometries['fallback'].push(...coords);
          L.polyline(coords, {
            color: '#0066B3', weight: 3, opacity: 0.6
          }).addTo(this.lineLayers['fallback'])
            .bindPopup(`<b>Tramlinie</b><br>Shape: ${shapeId}`);
          count++;
        }
      });

      console.log(`‚úÖ ${count} GTFS-Shapes geladen (Fallback)`);
      this.updateLineControl();
      
    } catch (error) {
      console.error('GTFS-Fallback fehlgeschlagen:', error);
      this.showError('lineCheckboxes', 'Fehler beim Laden der Strecken');
    }
  },

  updateLineControl() {
    const container = document.getElementById('lineCheckboxes');
    container.innerHTML = '';

    const lineNumbers = Object.keys(this.lineLayers).sort((a, b) => {
      const numA = parseInt(a) || 999;
      const numB = parseInt(b) || 999;
      return numA - numB;
    });

    lineNumbers.forEach(lineNumber => {
      const color = CONFIG.LINE_COLORS[lineNumber] || '#0066B3';
      const isVisible = this.map.hasLayer(this.lineLayers[lineNumber]);

      const div = document.createElement('div');
      div.className = 'checkbox-option';

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.id = `line-${lineNumber}`;
      checkbox.checked = isVisible;
      checkbox.onchange = () => this.toggleLine(lineNumber);

      const label = document.createElement('label');
      label.htmlFor = `line-${lineNumber}`;
      label.className = 'line-label';

      const colorBox = document.createElement('span');
      colorBox.className = 'line-color-box';
      colorBox.style.backgroundColor = color;

      label.appendChild(colorBox);
      label.appendChild(document.createTextNode(`Linie ${lineNumber}`));

      div.appendChild(checkbox);
      div.appendChild(label);
      container.appendChild(div);
    });
  },

  toggleLine(lineNumber) {
    const layer = this.lineLayers[lineNumber];
    if (!layer) return;

    if (this.map.hasLayer(layer)) {
      this.map.removeLayer(layer);
    } else {
      layer.addTo(this.map);
    }
  },

  toggleAllLines(show) {
    Object.keys(this.lineLayers).forEach(lineNumber => {
      const layer = this.lineLayers[lineNumber];
      const checkbox = document.getElementById(`line-${lineNumber}`);

      if (show) {
        if (!this.map.hasLayer(layer)) layer.addTo(this.map);
        if (checkbox) checkbox.checked = true;
      } else {
        if (this.map.hasLayer(layer)) this.map.removeLayer(layer);
        if (checkbox) checkbox.checked = false;
      }
    });
  },

  // ==================== HALTESTELLEN ====================
  async loadStops() {
    this.showLoading('stopsStatus', 'Lade Haltestellen...');
    
    try {
      const response = await fetch('https://gtfs.geops.ch/dl/tram/stops.txt');
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      
      const csvText = await response.text();
      const parsed = Papa.parse(csvText, { header: true });
      const stops = parsed.data.filter(s => s.stop_name && s.stop_lat && s.stop_lon);

      this.tramLayer.clearLayers();
      this.stopMarkers = [];
      this.stopCoordinates = {};

      stops.forEach(stop => {
        const lat = parseFloat(stop.stop_lat);
        const lon = parseFloat(stop.stop_lon);
        const name = stop.stop_name;
        const stopId = stop.stop_id;
        const wheelchairBoarding = stop.wheelchair_boarding || '0';

        // Speichere Koordinaten f√ºr sp√§tere Nutzung
        this.stopCoordinates[stopId] = { lat, lon, name };

        const icon = this.createAccessibilityIcon(wheelchairBoarding);
        const marker = L.marker([lat, lon], { icon }).addTo(this.tramLayer);

        const accessibilityText = this.getAccessibilityText(wheelchairBoarding);
        marker.bindPopup(`<div class="popup-header">${name}</div><div class="popup-section">${accessibilityText}<br><small>Klicken f√ºr Abfahrten...</small></div>`);

        marker.on('click', () => this.loadDepartures(marker, name, accessibilityText));

        this.stopMarkers.push({ marker, name, wheelchairBoarding, stopId });
      });

      console.log(`‚úÖ ${stops.length} Haltestellen geladen`);
      this.showSuccess('stopsStatus', `${stops.length} Haltestellen geladen`);
      this.filterStops();
      
    } catch (error) {
      console.error('Fehler beim Laden der Haltestellen:', error);
      this.showError('stopsStatus', 'Fehler beim Laden');
    }
  },

  async loadDepartures(marker, name, accessibilityText) {
    marker.setPopupContent(`<div class="popup-header">${name}</div><div class="popup-section">${accessibilityText}<br><small>‚è≥ Lade Abfahrten...</small></div>`);

    try {
      const url = `https://transport.opendata.ch/v1/stationboard?station=${encodeURIComponent(name)}&limit=5&transportations[]=tram`;
      const response = await fetch(url);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      
      const data = await response.json();

      if (!data.stationboard || data.stationboard.length === 0) {
        marker.setPopupContent(`<div class="popup-header">${name}</div><div class="popup-section">${accessibilityText}<br>Keine Abfahrten verf√ºgbar.</div>`);
        return;
      }

      let html = `<div class="popup-header">${name}</div><div class="popup-section">${accessibilityText}</div><div class="popup-section"><b>N√§chste Abfahrten:</b><ul style="margin:5px 0 0 0;padding-left:15px;">`;

      data.stationboard.forEach(dep => {
        const depTime = new Date(dep.stop.departure);
        const diffMin = Math.round((depTime - Date.now()) / 60000);
        const minutesText = diffMin < 0 ? "Abgefahren" : `in ${diffMin} min`;

        let delayClass = 'delay-ontime';
        let delayText = 'p√ºnktlich';
        if (dep.stop.delay > 3) {
          delayClass = 'delay-major';
          delayText = `+${dep.stop.delay} min`;
        } else if (dep.stop.delay > 0) {
          delayClass = 'delay-minor';
          delayText = `+${dep.stop.delay} min`;
        }

        html += `<li>${dep.category} ${dep.number} ‚Üí ${dep.to}<br>
                 <small>${depTime.toLocaleTimeString('de-CH', {hour: '2-digit', minute: '2-digit'})} (${minutesText}) 
                 <span class="delay-indicator ${delayClass}">${delayText}</span></small></li>`;
      });
      html += '</ul></div>';

      marker.setPopupContent(html);
      
    } catch (error) {
      console.error('Fehler beim Laden der Abfahrten:', error);
      marker.setPopupContent(`<div class="popup-header">${name}</div><div class="popup-section">${accessibilityText}<br>‚ùå Fehler beim Laden</div>`);
    }
  },

  filterStops() {
    const showStops = document.getElementById('showStops')?.checked ?? true;

    this.stopMarkers.forEach(({ marker }) => {
      if (showStops) {
        if (!this.tramLayer.hasLayer(marker)) {
          marker.addTo(this.tramLayer);
        }
      } else {
        if (this.tramLayer.hasLayer(marker)) {
          this.tramLayer.removeLayer(marker);
        }
      }
    });
  },

  // ==================== FAHRZEUGE ====================
  async loadVehicles() {
    if (!document.getElementById('showVehicles')?.checked) return;
    
    try {
      const activeVehicles = {};
      const stationPromises = CONFIG.MAJOR_STOPS.map(station => 
        this.fetchStationData(station)
      );

      const stationResults = await Promise.allSettled(stationPromises);

      stationResults.forEach((result, index) => {
        if (result.status === 'fulfilled' && result.value) {
          const station = CONFIG.MAJOR_STOPS[index];
          this.processStationData(result.value, station, activeVehicles);
        }
      });

      this.updateVehicleMarkers(activeVehicles);
      this.updateVehicleStats(activeVehicles);

    } catch (error) {
      console.error('Fehler beim Laden der Fahrzeuge:', error);
      this.showError('vehicleStats', 'Fehler beim Laden');
    }
  },

  processStationData(data, stationName, activeVehicles) {
    if (!data.stationboard) return;

    const now = new Date();
    const coord = data.station?.coordinate;

    data.stationboard.forEach(dep => {
      try {
        const isTram = dep.category === 'T' || dep.category === 'Tram' ||
                       (dep.number && parseInt(dep.number) >= 2 && parseInt(dep.number) <= 17);
        
        if (!isTram || !dep.stop?.departure) return;

        const depTime = new Date(dep.stop.departure);
        const diffMin = (depTime - now) / 60000;

        // Erweitere Zeitfenster: Trams die in den letzten 10 Min abgefahren sind oder in 5 Min abfahren
        if (diffMin < -10 || diffMin > 5) return;

        // Eindeutige ID
        const delayInMs = (dep.stop.delay || 0) * 60000;
        const plannedDepartureTime = new Date(depTime.getTime() - delayInMs);
        const vehicleId = `${dep.number}-${(dep.to || 'unknown').substring(0, 20)}-${plannedDepartureTime.getTime()}`;
        
        if (!activeVehicles[vehicleId]) {
          const nextStation = this.findNextStation(stationName, dep.to, dep.number);
          const nextStationCoord = this.findStationCoordinates(nextStation);
          
          // Sch√§tze Ankunftszeit: 2-4 Minuten Fahrzeit pro Station
          const estimatedTravelTime = 3 * 60 * 1000; // 3 Minuten in Millisekunden
          const arrivalTime = new Date(depTime.getTime() + estimatedTravelTime);
          
          activeVehicles[vehicleId] = {
            lineNumber: dep.number,
            destination: dep.to || 'Unbekannt',
            currentStation: stationName,
            nextStation: nextStation,
            delay: dep.stop.delay || 0,
            departureTime: depTime,
            plannedDepartureTime: plannedDepartureTime,
            diffMin: Math.round(diffMin),
            stationCoord: { lat: coord?.x || 47.3769, lon: coord?.y || 8.5417 },
            journey: {
              fromStation: stationName,
              toStation: nextStation,
              departureTime: depTime,
              arrivalTime: arrivalTime,
              nextStationCoord: nextStationCoord
            }
          };
        }
      } catch (error) {
        console.warn('Fehler beim Verarbeiten von Departure:', error, dep);
      }
    });
  },

  // Finde Koordinaten einer Station anhand des Namens
  findStationCoordinates(stationName) {
    const stop = this.stopMarkers.find(s => s.name === stationName);
    if (stop && this.stopCoordinates[stop.stopId]) {
      return this.stopCoordinates[stop.stopId];
    }
    
    // Fallback: Suche in stopCoordinates
    for (const stopId in this.stopCoordinates) {
      if (this.stopCoordinates[stopId].name === stationName) {
        return this.stopCoordinates[stopId];
      }
    }
    
    return null;
  },

  findNextStation(currentStation, destination, lineNumber) {
    // Vereinfachte Streckenlogik
    const routes = {
      'Z√ºrich HB': {
        '2': 'Z√ºrich, Paradeplatz',
        '3': 'Z√ºrich, Central',
        '4': 'Z√ºrich, Bellevue',
        '6': 'Z√ºrich, Paradeplatz',
        '7': 'Z√ºrich, Central',
        '11': 'Z√ºrich, Paradeplatz',
        '13': 'Z√ºrich, Bahnhofquai/HB'
      },
      'Z√ºrich, Paradeplatz': {
        '2': 'Z√ºrich, B√ºrkliplatz',
        '6': 'Z√ºrich, Bellevue',
        '11': 'Z√ºrich, Bellevue'
      },
      'Z√ºrich, Bellevue': {
        '2': 'Z√ºrich, Feldeggstrasse',
        '4': 'Z√ºrich, H√∂schgasse',
        '5': 'Z√ºrich, Kirche Fluntern'
      },
      'Z√ºrich, Central': {
        '3': 'Z√ºrich, Limmatplatz',
        '7': 'Z√ºrich, Escher-Wyss-Platz'
      }
    };

    return routes[currentStation]?.[lineNumber] || destination;
  },

  updateVehicleMarkers(activeVehicles) {
    const currentIds = new Set(Object.keys(activeVehicles));

    // Alte Marker entfernen
    Object.keys(this.vehicleMarkers).forEach(id => {
      if (!currentIds.has(id)) {
        const marker = this.vehicleMarkers[id];
        this.vehicleLayer.removeLayer(marker);
        marker.off();
        delete this.vehicleMarkers[id];
        delete this.vehicleAnimationState[id];
      }
    });

    // Neue/bestehende Marker aktualisieren
    Object.entries(activeVehicles).forEach(([id, vehicle]) => {
      try {
        if (this.vehicleMarkers[id]) {
          this.updateExistingVehicle(id, vehicle);
        } else {
          this.createNewVehicle(id, vehicle);
        }
      } catch (error) {
        console.warn(`Fehler beim Update von Fahrzeug ${id}:`, error);
      }
    });
  },

  createNewVehicle(id, vehicle) {
    const color = CONFIG.LINE_COLORS[vehicle.lineNumber] || '#0066B3';
    
    // Berechne Position basierend auf Fahrplan mit realistischer Physik
    const positionData = this.calculateRealisticPosition(vehicle);
    
    const icon = this.createVehicleIcon(vehicle.lineNumber, color, vehicle.delay);
    const marker = L.marker([positionData.lat, positionData.lon], { icon })
      .addTo(this.vehicleLayer);

    this.vehicleMarkers[id] = marker;
    this.updateVehiclePopup(marker, vehicle);

    // Animationszustand initialisieren
    const trackCoords = this.lineGeometries[vehicle.lineNumber];
    const trackIndex = trackCoords && trackCoords.length > 0 
      ? this.findNearestPointOnLine(positionData.lat, positionData.lon, trackCoords)
      : 0;

    this.vehicleAnimationState[id] = {
      lineNumber: vehicle.lineNumber,
      trackIndex: trackIndex,
      vehicle: vehicle,
      physics: {
        phase: positionData.phase,
        speed: positionData.speed,
        lastUpdate: Date.now()
      }
    };
  },

  // KERNFUNKTION: Berechne realistische Position mit konsistenten Haltestellen
  calculateRealisticPosition(vehicle) {
    try {
      const now = new Date();
      const journey = vehicle.journey;
      
      if (!journey || !journey.departureTime) {
        return { 
          lat: vehicle.stationCoord.lat, 
          lon: vehicle.stationCoord.lon,
          phase: 'stopped',
          speed: 0
        };
      }
      
      const departureTime = journey.departureTime;
      const timeSinceDeparture = (now - departureTime) / 1000; // Sekunden
      
      // PHASE 1: Noch nicht abgefahren (steht an Start-Haltestelle)
      if (timeSinceDeparture < 0) {
        return {
          lat: vehicle.stationCoord.lat,
          lon: vehicle.stationCoord.lon,
          phase: 'waiting',
          speed: 0,
          secondsUntilDeparture: Math.abs(timeSinceDeparture)
        };
      }
      
      // Finde Route zwischen Start und Ziel
      const route = this.findRouteBetweenStations(vehicle.currentStation, vehicle.nextStation, vehicle.lineNumber);
      
      if (!route || route.length < 2) {
        // Fallback: Einfache Interpolation
        return this.calculateSimplePosition(vehicle, timeSinceDeparture);
      }
      
      // Berechne Position auf der Route MIT HALTESTELLEN-STOPS
      return this.calculatePositionOnRouteWithStops(vehicle, route, timeSinceDeparture);
      
    } catch (error) {
      console.warn('Fehler bei calculateRealisticPosition:', error);
      return { 
        lat: vehicle.stationCoord.lat, 
        lon: vehicle.stationCoord.lon,
        phase: 'error',
        speed: 0
      };
    }
  },

  // Finde Route zwischen zwei Haltestellen
  findRouteBetweenStations(fromStation, toStation, lineNumber) {
    const trackCoords = this.lineGeometries[lineNumber];
    if (!trackCoords || trackCoords.length === 0) return null;
    
    const fromCoord = this.findStationCoordinates(fromStation);
    const toCoord = this.findStationCoordinates(toStation);
    
    if (!fromCoord || !toCoord) return null;
    
    const fromIndex = this.findNearestPointOnLine(fromCoord.lat, fromCoord.lon, trackCoords);
    const toIndex = this.findNearestPointOnLine(toCoord.lat, toCoord.lon, trackCoords);
    
    const route = [];
    const step = fromIndex <= toIndex ? 1 : -1;
    
    for (let i = fromIndex; step > 0 ? i <= toIndex : i >= toIndex; i += step) {
      route.push({
        lat: trackCoords[i][0],
        lon: trackCoords[i][1]
      });
    }
    
    return route;
  },

  // NEU: Berechne Position mit garantierten Haltestellen-Stops
  calculatePositionOnRouteWithStops(vehicle, route, timeSinceDeparture) {
    // Identifiziere alle Haltestellen auf der Route
    const stopsOnRoute = this.findStopsOnRoute(route);
    
    if (stopsOnRoute.length === 0) {
      // Keine Haltestellen gefunden - normale Bewegung
      return this.calculateSimpleRoutePosition(route, timeSinceDeparture);
    }
    
    // Berechne Gesamtfahrzeit mit Stopps
    const totalTravelTime = this.calculateTravelTimeWithStops(route, stopsOnRoute);
    const progress = Math.min(timeSinceDeparture / totalTravelTime, 1.0);
    
    // Finde aktuellen Streckenabschnitt basierend auf progress
    return this.findCurrentSegmentWithStops(route, stopsOnRoute, progress, timeSinceDeparture);
  },

  // NEU: Finde alle Haltestellen auf der Route
  findStopsOnRoute(route) {
    const stops = [];
    
    for (let i = 0; i < route.length; i++) {
      const point = route[i];
      const stopInfo = this.findStopAtPosition(point.lat, point.lon);
      if (stopInfo) {
        stops.push({
          index: i,
          lat: point.lat,
          lon: point.lon,
          name: stopInfo.name,
          stopId: stopInfo.stopId
        });
      }
    }
    
    return stops;
  },

  // NEU: Finde Haltestelle an Position
  findStopAtPosition(lat, lon) {
    for (const stopId in this.stopCoordinates) {
      const stop = this.stopCoordinates[stopId];
      const distance = this.calculateDistance(lat, lon, stop.lat, stop.lon);
      if (distance < 30) { // 30 Meter Radius
        return {
          name: stop.name,
          stopId: stopId,
          lat: stop.lat,
          lon: stop.lon
        };
      }
    }
    return null;
  },

  // NEU: Berechne Fahrzeit mit Stopps
  calculateTravelTimeWithStops(route, stops) {
    const totalDistance = this.calculateRouteDistance(route);
    const averageSpeed = 25; // km/h
    const drivingTime = (totalDistance / 1000) / (averageSpeed / 3600);
    
    // F√ºge Stopp-Zeiten hinzu (30 Sekunden pro Haltestelle)
    const stopTime = stops.length * CONFIG.STOP_DURATION;
    
    return drivingTime + stopTime;
  },

  // NEU: Finde aktuelles Segment mit Haltestellen-Stops
  findCurrentSegmentWithStops(route, stops, progress, timeSinceDeparture) {
    const totalTravelTime = this.calculateTravelTimeWithStops(route, stops);
    const currentTime = progress * totalTravelTime;
    
    let accumulatedTime = 0;
    let segmentStartIndex = 0;
    
    // Gehe durch alle Segmente zwischen Haltestellen
    for (let i = 0; i < stops.length; i++) {
      const currentStop = stops[i];
      const nextStop = stops[i + 1] || { index: route.length - 1 };
      
      // Berechne Fahrzeit zu dieser Haltestelle
      const segmentRoute = route.slice(segmentStartIndex, currentStop.index + 1);
      const segmentDistance = this.calculateRouteDistance(segmentRoute);
      const segmentTravelTime = (segmentDistance / 1000) / (25 / 3600); // 25 km/h
      
      // Zeitpunkt an dem wir an der Haltestelle ankommen
      const arrivalTime = accumulatedTime + segmentTravelTime;
      
      // Zeitpunkt an dem wir die Haltestelle verlassen
      const departureTime = arrivalTime + CONFIG.STOP_DURATION;
      
      // Sind wir vor der Haltestelle?
      if (currentTime < arrivalTime) {
        const segmentProgress = currentTime / arrivalTime;
        return this.interpolateInSegment(route, segmentStartIndex, currentStop.index, segmentProgress, 'traveling');
      }
      
      // Sind wir an der Haltestelle?
      if (currentTime >= arrivalTime && currentTime < departureTime) {
        return {
          lat: currentStop.lat,
          lon: currentStop.lon,
          phase: 'stopped',
          speed: 0
        };
      }
      
      // Sind wir nach der Haltestelle?
      if (currentTime >= departureTime) {
        accumulatedTime = departureTime;
        segmentStartIndex = currentStop.index;
        
        // Wenn letzte Haltestelle
        if (!nextStop.index) {
          const remainingProgress = (currentTime - departureTime) / (totalTravelTime - departureTime);
          return this.interpolateInSegment(route, currentStop.index, route.length - 1, remainingProgress, 'traveling');
        }
      }
    }
    
    // Fallback: Normale Interpolation
    return this.calculateSimpleRoutePosition(route, timeSinceDeparture);
  },

  // NEU: Interpoliere in einem Segment
  interpolateInSegment(route, startIndex, endIndex, progress, phase) {
    const segmentLength = endIndex - startIndex;
    const currentIndex = startIndex + Math.floor(segmentLength * progress);
    const nextIndex = Math.min(currentIndex + 1, endIndex);
    
    const segmentProgress = (segmentLength * progress) - Math.floor(segmentLength * progress);
    
    const lat = route[currentIndex].lat + (route[nextIndex].lat - route[currentIndex].lat) * segmentProgress;
    const lon = route[currentIndex].lon + (route[nextIndex].lon - route[currentIndex].lon) * segmentProgress;
    
    // Bestimme Geschwindigkeit basierend auf Phase
    let speed = CONFIG.MAX_SPEED;
    if (phase === 'accelerating') speed = 15;
    else if (phase === 'braking') speed = 10;
    else if (phase === 'stopped') speed = 0;
    
    return { lat, lon, phase, speed };
  },

  // NEU: Vereinfachte Routen-Position (Fallback)
  calculateSimpleRoutePosition(route, timeSinceDeparture) {
    const estimatedTravelTime = 3 * 60; // 3 Minuten
    const progress = Math.min(timeSinceDeparture / estimatedTravelTime, 1.0);
    
    const targetIndex = Math.floor((route.length - 1) * progress);
    const nextIndex = Math.min(targetIndex + 1, route.length - 1);
    const segmentProgress = ((route.length - 1) * progress) - targetIndex;
    
    const lat = route[targetIndex].lat + (route[nextIndex].lat - route[targetIndex].lat) * segmentProgress;
    const lon = route[targetIndex].lon + (route[nextIndex].lon - route[targetIndex].lon) * segmentProgress;
    
    let phase = 'constant';
    let speed = CONFIG.MAX_SPEED;
    
    if (progress < 0.1) {
      phase = 'accelerating';
      speed = CONFIG.MAX_SPEED * (progress / 0.1);
    } else if (progress > 0.9) {
      phase = 'braking';
      speed = CONFIG.MAX_SPEED * (1 - ((progress - 0.9) / 0.1));
    } else if (progress >= 1.0) {
      phase = 'arrived';
      speed = 0;
    }
    
    return { lat, lon, phase, speed };
  },

  // Fallback f√ºr einfache Positionsberechnung
  calculateSimplePosition(vehicle, timeSinceDeparture) {
    const journey = vehicle.journey;
    if (!journey?.nextStationCoord) {
      return {
        lat: vehicle.stationCoord.lat,
        lon: vehicle.stationCoord.lon,
        phase: 'stopped',
        speed: 0
      };
    }

    const estimatedTravelTime = 3 * 60; // 3 Minuten in Sekunden
    const progress = Math.min(timeSinceDeparture / estimatedTravelTime, 1.0);
    
    let phase = 'constant';
    let speed = CONFIG.MAX_SPEED;
    
    if (progress < 0.1) {
      phase = 'accelerating';
      speed = CONFIG.MAX_SPEED * (progress / 0.1);
    } else if (progress > 0.9) {
      phase = 'braking';
      speed = CONFIG.MAX_SPEED * (1 - ((progress - 0.9) / 0.1));
    } else if (progress >= 1.0) {
      phase = 'arrived';
      speed = 0;
    }

    const lat = vehicle.stationCoord.lat + (journey.nextStationCoord.lat - vehicle.stationCoord.lat) * progress;
    const lon = vehicle.stationCoord.lon + (journey.nextStationCoord.lon - vehicle.stationCoord.lon) * progress;

    return { lat, lon, phase, speed };
  },

  async fetchStationData(station) {
    try {
      const url = `https://transport.opendata.ch/v1/stationboard?station=${encodeURIComponent(station)}&limit=15&transportations[]=tram`;
      const response = await fetch(url);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      return await response.json();
    } catch (error) {
      console.warn(`Fehler bei Station ${station}:`, error);
      return null;
    }
  },

  updateExistingVehicle(id, vehicle) {
    const marker = this.vehicleMarkers[id];
    this.updateVehiclePopup(marker, vehicle);
  },

  updateVehiclePopup(marker, vehicle) {
    const color = CONFIG.LINE_COLORS[vehicle.lineNumber] || '#0066B3';
    const textColor = this.isColorDark(color) ? '#ffffff' : '#000000';

    let delayClass = 'delay-ontime';
    let delayText = 'P√ºnktlich';
    
    if (vehicle.delay > 3) {
      delayClass = 'delay-major';
      delayText = `${vehicle.delay} Min. Versp√§tung`;
    } else if (vehicle.delay > 0) {
      delayClass = 'delay-minor';
      delayText = `${vehicle.delay} Min. Versp√§tung`;
    }

    const positionData = this.calculateRealisticPosition(vehicle);
    const statusText = this.getStatusText(positionData, vehicle);

    const popupContent = `
      <div class="popup-header">
        <span style="background: ${color}; color: ${textColor}; padding: 4px 8px; border-radius: 4px;">
          Linie ${vehicle.lineNumber}
        </span>
      </div>
      <div class="popup-section">
        <b>Ziel:</b> ${vehicle.destination}<br>
        <b>Status:</b> ${statusText}<br>
        <b>Geschwindigkeit:</b> ${Math.round(positionData.speed)} km/h<br>
        <b>P√ºnktlichkeit:</b> <span class="delay-indicator ${delayClass}">${delayText}</span>
      </div>
      <div class="popup-section">
        <small><b>Von:</b> ${vehicle.currentStation}</small><br>
        <small><b>Nach:</b> ${vehicle.nextStation}</small><br>
        <small><b>Abfahrt:</b> ${vehicle.departureTime.toLocaleTimeString('de-CH', {hour: '2-digit', minute: '2-digit'})}</small>
      </div>
    `;

    marker.bindPopup(popupContent);
  },

  getStatusText(positionData, vehicle) {
    if (positionData.phase === 'stopped') {
      // Finde den Namen der aktuellen Haltestelle
      const currentStop = this.findNearestStopName(positionData.lat, positionData.lon);
      return `H√§lt an ${currentStop || 'Haltestelle'}`;
    }
    
    switch(positionData.phase) {
      case 'waiting':
        return `Steht an ${vehicle.currentStation} (f√§hrt in ${Math.round(positionData.secondsUntilDeparture)}s)`;
      case 'accelerating':
        return `Beschleunigt von ${vehicle.currentStation}`;
      case 'constant':
        const nextStop = this.findNextStopName(vehicle);
        return `F√§hrt ‚Üí ${nextStop}`;
      case 'braking':
        const approachingStop = this.findNextStopName(vehicle);
        return `Bremst vor ${approachingStop}`;
      case 'arrived':
        return `Angekommen an ${vehicle.destination}`;
      default:
        return 'Unterwegs';
    }
  },

  findNearestStopName(lat, lon) {
    let nearestStop = null;
    let minDistance = Infinity;
    
    Object.values(this.stopCoordinates).forEach(stop => {
      const distance = this.calculateDistance(lat, lon, stop.lat, stop.lon);
      if (distance < minDistance && distance < 50) { // innerhalb 50 Meter
        minDistance = distance;
        nearestStop = stop.name;
      }
    });
    
    return nearestStop;
  },

  findNextStopName(vehicle) {
    return vehicle.nextStation || vehicle.destination;
  },

  updateVehicleStats(activeVehicles) {
    const statsDiv = document.getElementById('vehicleStats');
    if (!statsDiv) return;

    try {
      const vehicleCount = Object.keys(activeVehicles).length;
      
      if (vehicleCount === 0) {
        statsDiv.innerHTML = `
          <small>Keine aktiven Fahrzeuge gefunden</small><br>
          <small style="color: #666;">Warte auf Tram-Abfahrten...</small>
        `;
        return;
      }

      // Berechne Phasen
      let waiting = 0, accelerating = 0, constant = 0, braking = 0, stopped = 0, arrived = 0;
      
      Object.values(this.vehicleAnimationState).forEach(state => {
        if (state.physics) {
          switch(state.physics.phase) {
            case 'waiting': waiting++; break;
            case 'accelerating': accelerating++; break;
            case 'constant': constant++; break;
            case 'braking': braking++; break;
            case 'stopped': stopped++; break;
            case 'arrived': arrived++; break;
          }
        }
      });

      statsDiv.innerHTML = `
        <b>${vehicleCount}</b> Fahrzeuge aktiv<br>
        <small>‚è≥ ${waiting} warten</small><br>
        <small>‚ñ≤ ${accelerating} beschleunigen</small><br>
        <small>‚óè ${constant} konstante Fahrt</small><br>
        <small>‚ñº ${braking} bremsen</small><br>
        <small>üõë ${stopped} halten</small><br>
        <small>‚úì ${arrived} angekommen</small>
      `;
    } catch (error) {
      console.warn('Fehler bei updateVehicleStats:', error);
      statsDiv.innerHTML = '<small style="color: #ef4444;">Fehler bei Statistik</small>';
    }
  },

  toggleVehicles() {
    const show = document.getElementById('showVehicles').checked;

    if (show) {
      if (!this.map.hasLayer(this.vehicleLayer)) {
        this.vehicleLayer.addTo(this.map);
      }
      this.loadVehicles();
    } else {
      if (this.map.hasLayer(this.vehicleLayer)) {
        this.map.removeLayer(this.vehicleLayer);
      }
    }
  },

  // ==================== ANIMATION ====================
  startAnimation() {
    const animate = () => {
      this.animateVehicles();
      this.animationFrameId = requestAnimationFrame(animate);
    };
    animate();
  },

  stopAnimation() {
    if (this.animationFrameId) {
      cancelAnimationFrame(this.animationFrameId);
      this.animationFrameId = null;
    }
  },

  animateVehicles() {
    const animateEnabled = document.getElementById('animateOnTracks')?.checked ?? true;
    if (!animateEnabled) return;

    const now = Date.now();
    
    Object.entries(this.vehicleAnimationState).forEach(([id, state]) => {
      try {
        const marker = this.vehicleMarkers[id];
        if (!marker) return;

        const vehicle = state.vehicle;
        if (!vehicle) return;

        // Verwende die verbesserte Position mit Haltestellen
        const positionData = this.calculateRealisticPosition(vehicle);
        
        // Setze Marker auf berechnete Position
        marker.setLatLng([positionData.lat, positionData.lon]);
        
        // Update Animation State
        if (!state.physics) {
          state.physics = {
            phase: positionData.phase,
            speed: positionData.speed,
            lastUpdate: now
          };
        } else {
          state.physics.phase = positionData.phase;
          state.physics.speed = positionData.speed;
          state.physics.lastUpdate = now;
        }
        
        // Update Visuals
        this.updateVehicleVisualWithPhase(marker, state, positionData);
        
      } catch (error) {
        console.warn(`Fehler bei Animation von Fahrzeug ${id}:`, error);
      }
    });
  },

  updateVehicleVisualWithPhase(marker, state, positionData) {
    const color = CONFIG.LINE_COLORS[state.lineNumber] || '#0066B3';
    const textColor = this.isColorDark(color) ? '#ffffff' : '#000000';

    let statusIcon = '';
    let statusClass = '';

    switch (positionData.phase) {
      case 'waiting':
      case 'stopped':
        statusIcon = '‚ñ†';
        statusClass = 'stopped';
        break;
      case 'accelerating':
        statusIcon = '‚ñ≤';
        statusClass = 'accelerating';
        break;
      case 'constant':
        statusIcon = '‚óè';
        statusClass = 'constant';
        break;
      case 'braking':
        statusIcon = '‚ñº';
        statusClass = 'braking';
        break;
      case 'arrived':
        statusIcon = '‚úì';
        statusClass = 'stopped';
        break;
      default:
        statusIcon = '‚óè';
        statusClass = '';
    }

    marker.setIcon(L.divIcon({
      html: `<div class="vehicle-marker ${statusClass}" style="background-color: ${color}; color: ${textColor}; border-color: ${color};">
               ${state.lineNumber}${statusIcon}
             </div>`,
      className: 'vehicle-marker-wrapper',
      iconSize: [40, 40],
      iconAnchor: [20, 20]
    }));

    // Update Popup wenn offen
    if (marker.isPopupOpen()) {
      this.updateLivePopup(marker, state.vehicle, positionData);
    }
  },

  updateLivePopup(marker, vehicle, positionData) {
    const color = CONFIG.LINE_COLORS[vehicle.lineNumber] || '#0066B3';
    const textColor = this.isColorDark(color) ? '#ffffff' : '#000000';

    let delayClass = 'delay-ontime';
    let delayText = 'P√ºnktlich';
    
    if (vehicle.delay > 3) {
      delayClass = 'delay-major';
      delayText = `${vehicle.delay} Min. Versp√§tung`;
    } else if (vehicle.delay > 0) {
      delayClass = 'delay-minor';
      delayText = `${vehicle.delay} Min. Versp√§tung`;
    }

    const statusText = this.getStatusText(positionData, vehicle);

    const popupContent = `
      <div class="popup-header">
        <span style="background: ${color}; color: ${textColor}; padding: 4px 8px; border-radius: 4px;">
          Linie ${vehicle.lineNumber}
        </span>
      </div>
      <div class="popup-section">
        <b>Ziel:</b> ${vehicle.destination}<br>
        <b>Status:</b> ${statusText}<br>
        <b>Geschwindigkeit:</b> ${Math.round(positionData.speed)} km/h<br>
        <b>P√ºnktlichkeit:</b> <span class="delay-indicator ${delayClass}">${delayText}</span>
      </div>
      <div class="popup-section">
        <small><b>Von:</b> ${vehicle.currentStation}</small><br>
        <small><b>Nach:</b> ${vehicle.nextStation}</small><br>
        <small><b>Abfahrt:</b> ${vehicle.departureTime.toLocaleTimeString('de-CH', {hour: '2-digit', minute: '2-digit'})}</small>
      </div>
    `;

    marker.setPopupContent(popupContent);
  },

  // ==================== HILFSFUNKTIONEN ====================
  createVehicleIcon(lineNumber, color, delay) {
    const textColor = this.isColorDark(color) ? '#ffffff' : '#000000';
    let delayIndicator = '';
    if (delay > 3) delayIndicator = '‚ö†';
    else if (delay > 0) delayIndicator = '‚óÜ';

    return L.divIcon({
      html: `<div class="vehicle-marker" style="background-color: ${color}; color: ${textColor}; border-color: ${color};">
               ${lineNumber}${delayIndicator}
             </div>`,
      className: 'vehicle-marker-wrapper',
      iconSize: [40, 40],
      iconAnchor: [20, 20]
    });
  },

  createAccessibilityIcon(wheelchairBoarding) {
    let color;
    if (wheelchairBoarding === '1') color = '#22c55e';
    else if (wheelchairBoarding === '2') color = '#ef4444';
    else color = '#94a3b8';

    const svg = `<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                   <circle cx="12" cy="12" r="8" fill="${color}" stroke="#333" stroke-width="2"/>
                 </svg>`;

    return L.divIcon({
      html: svg,
      className: 'custom-marker',
      iconSize: [24, 24],
      iconAnchor: [12, 12],
      popupAnchor: [0, -12]
    });
  },

  getAccessibilityText(wheelchairBoarding) {
    if (wheelchairBoarding === '1') {
      return '‚ôø <span style="color: #22c55e; font-weight: bold;">Barrierefrei</span>';
    } else if (wheelchairBoarding === '2') {
      return '‚ôø <span style="color: #ef4444; font-weight: bold;">Nicht barrierefrei</span>';
    } else {
      return '‚ôø <span style="color: #94a3b8;">Barrierefreiheit unbekannt</span>';
    }
  },

  isColorDark(hexColor) {
    const color = hexColor.replace('#', '');
    const r = parseInt(color.substr(0, 2), 16);
    const g = parseInt(color.substr(2, 2), 16);
    const b = parseInt(color.substr(4, 2), 16);
    const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
    return luminance < 0.5;
  },

  findNearestPointOnLine(lat, lon, lineCoords) {
    let minDist = Infinity;
    let nearestIndex = 0;

    for (let i = 0; i < lineCoords.length; i++) {
      const dx = lineCoords[i][0] - lat;
      const dy = lineCoords[i][1] - lon;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < minDist) {
        minDist = dist;
        nearestIndex = i;
      }
    }

    return nearestIndex;
  },

  // Haversine-Formel f√ºr Distanzberechnung
  calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371000; // Erdradius in Metern
    const dLat = this.toRadians(lat2 - lat1);
    const dLon = this.toRadians(lon2 - lon1);
    
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
              Math.cos(this.toRadians(lat1)) * Math.cos(this.toRadians(lat2)) *
              Math.sin(dLon / 2) * Math.sin(dLon / 2);
    
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  },

  toRadians(degrees) {
    return degrees * (Math.PI / 180);
  },

  calculateRouteDistance(route) {
    let totalDistance = 0;
    for (let i = 0; i < route.length - 1; i++) {
      totalDistance += this.calculateDistance(
        route[i].lat, route[i].lon,
        route[i + 1].lat, route[i + 1].lon
      );
    }
    return totalDistance;
  },

  showLoading(elementId, message) {
    const el = document.getElementById(elementId);
    if (el) {
      el.innerHTML = `<div class="loading-indicator">‚è≥ ${message}</div>`;
    }
  },

  showError(elementId, message) {
    const el = document.getElementById(elementId);
    if (el) {
      el.innerHTML = `<div class="error-indicator">‚ùå ${message}</div>`;
    }
  },

  showSuccess(elementId, message) {
    const el = document.getElementById(elementId);
    if (el) {
      el.innerHTML = `<div class="loading-indicator" style="background: #d4edda; color: #155724;">‚úÖ ${message}</div>`;
    }
  }
};

// ==================== INITIALISIERUNG ====================
document.addEventListener('DOMContentLoaded', () => {
  app.init().catch(error => {
    console.error('Initialisierungsfehler:', error);
    alert('Fehler beim Starten der Anwendung. Bitte Seite neu laden.');
  });
});

console.log('üöÄ Z√ºrich Tramnetz Live - Mit konsistenten Haltestellen geladen');
</script>
</body>
</html>